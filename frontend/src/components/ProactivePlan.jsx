import { useState, useEffect, useRef } from 'react'
import { API_BASE } from '../config/api'
import './ProactivePlan.css'

const DISMISS_KEY = 'campus-ai-plan-dismissed'

function priorityLabel(score) {
  if (score >= 9) return { text: 'Urgent', cls: 'urgent' }
  if (score >= 6) return { text: 'High', cls: 'high' }
  if (score >= 4) return { text: 'Medium', cls: 'medium' }
  return { text: 'Low', cls: 'low' }
}

function formatSuggestedStart(dateStr) {
  if (!dateStr) return null
  const d = new Date(dateStr + 'T00:00:00')
  const today = new Date()
  today.setHours(0, 0, 0, 0)
  const diff = Math.round((d - today) / 86400000)
  if (diff === 0) return 'Start today'
  if (diff === 1) return 'Start tomorrow'
  if (diff < 0) return 'Should have started'
  return `Start ${d.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}`
}

export default function ProactivePlan({
  suggestions,       // { [assignmentId]: suggestion }
  assignments,       // full assignment list
  involvementLevel,
  onOpenChat,
  onPlanApplied,
  addToast,
}) {
  const [dismissed, setDismissed] = useState(() => {
    try {
      return localStorage.getItem(DISMISS_KEY) === new Date().toDateString()
    } catch { return false }
  })
  const [isApplying, setIsApplying] = useState(false)
  const [isGenerating, setIsGenerating] = useState(false)
  const [localSuggestions, setLocalSuggestions] = useState(suggestions)
  const hasAutoGenerated = useRef(false)

  // Keep local copy in sync unless we just generated our own
  useEffect(() => {
    setLocalSuggestions(suggestions)
  }, [suggestions])

  // Proactive: auto-generate if no suggestions exist yet
  useEffect(() => {
    if (involvementLevel !== 'proactive') return
    if (hasAutoGenerated.current) return
    if (Object.keys(localSuggestions).length > 0) return
    if (dismissed) return

    hasAutoGenerated.current = true
    const generate = async () => {
      setIsGenerating(true)
      try {
        const res = await fetch(`${API_BASE}/ai/suggestions/generate`, { method: 'POST' })
        if (res.ok) {
          const data = await res.json()
          const map = {}
          for (const s of (data.suggestions || [])) map[s.assignment_id] = s
          setLocalSuggestions(map)
        }
      } catch { /* silent */ } finally {
        setIsGenerating(false)
      }
    }
    generate()
  }, [involvementLevel, dismissed]) // eslint-disable-line react-hooks/exhaustive-deps

  const dismiss = () => {
    setDismissed(true)
    try { localStorage.setItem(DISMISS_KEY, new Date().toDateString()) } catch { /* ignore */ }
  }

  // Top suggestions sorted by priority, max 4
  const topItems = Object.values(localSuggestions)
    .sort((a, b) => (b.priority_score ?? 0) - (a.priority_score ?? 0))
    .slice(0, 4)
    .map((s) => ({
      suggestion: s,
      assignment: assignments.find((a) => a.id === s.assignment_id),
    }))
    .filter((item) => item.assignment)

  const applyPlan = async () => {
    const toApply = topItems.filter((item) => item.suggestion.suggested_start)
    if (!toApply.length) {
      addToast('No suggested start dates to apply.', 'error')
      return
    }
    setIsApplying(true)
    try {
      await Promise.all(
        toApply.map(({ suggestion, assignment }) =>
          fetch(`${API_BASE}/assignments/${assignment.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ planned_start: suggestion.suggested_start + 'T00:00:00.000Z' }),
          })
        )
      )
      addToast(`Schedule applied to ${toApply.length} assignment${toApply.length !== 1 ? 's' : ''}.`, 'success')
      onPlanApplied?.()
      dismiss()
    } catch {
      addToast('Failed to apply plan.', 'error')
    } finally {
      setIsApplying(false)
    }
  }

  // Don't render for prompt_only, or if dismissed, or if nothing to show
  if (involvementLevel === 'prompt_only') return null
  if (dismissed) return null
  if (!isGenerating && topItems.length === 0) return null

  return (
    <div className="proactive-card">
      <div className="proactive-header">
        <div className="proactive-title-row">
          <span className="proactive-badge">AI</span>
          <span className="proactive-title">Today&apos;s suggested plan</span>
        </div>
        <button className="proactive-dismiss" onClick={dismiss} aria-label="Dismiss">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
            <line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      </div>

      {isGenerating ? (
        <div className="proactive-generating">
          <span className="proactive-spinner" />
          <span>Analyzing your assignments…</span>
        </div>
      ) : (
        <>
          <ul className="proactive-list">
            {topItems.map(({ suggestion, assignment }) => {
              const prio = priorityLabel(suggestion.priority_score ?? 0)
              const startLabel = formatSuggestedStart(suggestion.suggested_start)
              return (
                <li key={assignment.id} className="proactive-item">
                  <div className="proactive-item-main">
                    <span className={`proactive-prio proactive-prio-${prio.cls}`}>{prio.text}</span>
                    <span className="proactive-item-title">{assignment.title}</span>
                    <span className="proactive-item-course">{assignment.course_name}</span>
                  </div>
                  <div className="proactive-item-meta">
                    {startLabel && <span className="proactive-start">{startLabel}</span>}
                    {suggestion.rationale && (
                      <span className="proactive-rationale">{suggestion.rationale}</span>
                    )}
                  </div>
                </li>
              )
            })}
          </ul>

          <div className="proactive-actions">
            <button
              className="proactive-apply"
              onClick={applyPlan}
              disabled={isApplying}
            >
              {isApplying ? 'Applying…' : 'Apply this plan'}
            </button>
            <button className="proactive-chat" onClick={() => { onOpenChat?.(); dismiss() }}>
              Chat to adjust
            </button>
          </div>
        </>
      )}
    </div>
  )
}
